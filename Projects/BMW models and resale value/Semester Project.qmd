---
title: "Fuel Type and Car Category: Analyzing Value Retention in the BMW Used Car Market"
execute:
  keep-md: true
  df-print: paged
  warning: false
format:
  html:
    code-fold: true
    embedded-resources: true
    self-contained: true
    code-line-numbers: true
---


In this project, I aim to answer two questions that are personally meaningful to me:

1. Performance & Value Retention (compact)
- If I want a powerful BMW that retains its value well as mileage increases, which series should I consider buying?

2. Family-Friendly & Durable (SUV)
If Iâ€™m looking for a family-friendly BMW SUV, which model best retains its value over mileage?

These questions combine both emotional and financial aspects of car ownership, helping identify models that deliver lasting performance, practicality, and investment value.

## Importing libraries

```{r}

library(reticulate)
library(dplyr)
library(lubridate)
library(stringr)
library(ggplot2)
library(scales)
library(pander)
library(broom)
library(gridExtra)
library(grid)
```


## Loading datasets

I got these 2 datasets from kaggle. I used reticulate and a python script to get the URLs, then used the paths to download the datasets. Both are sales of used bmw with columns like model, fuel type, car type, mpg, price, year, etc.

```{r}
py_run_string("import kagglehub
path = kagglehub.dataset_download('avikumart/bmwcsv')
path1 = kagglehub.dataset_download('danielkyrka/bmw-pricing-challenge')")

dataset_path <- py$path
dataset_path1 <- py$path1

bmw_models <- read.csv(file.path(dataset_path, 'bmw.csv')) %>% mutate(model = trimws(model))
bmw_sales <- read.csv(file.path(dataset_path1, 'bmw_pricing_challenge.csv')) %>% select(-maker_key, -matches("^feature_[1-8]$"))  #deleted the features since there was no explanation of their meaning

head(bmw_sales,20)
```


## 1. Performance & Value Retention (compact)

```{r}
head(bmw_models,20)
```


```{r}
bmw_models_edited <- bmw_models %>% filter(model %in% c("1 Series","2 Series", "3 Series", "5 Series"), year >2010 & year<2016, price <50000, engineSize>0 )
```


```{r}
# Calculate regression lines and slopes
regression_data <- bmw_models_edited %>%
  group_by(model, engineSize) %>%
  do({
    model <- lm(price ~ mileage, data = .)
    data.frame(
      slope = coef(model)[2],
      intercept = coef(model)[1])})

# Set fixed positions with different Y values to avoid overlap
label_positions <- regression_data %>%
  group_by(model) %>%
  mutate(
    x_pos = 130000, 
    y_pos = 18000 - (row_number() - 1) * 1250)
```



```{r, fig.width=15, fig.height=10}

# Create the plot with labels at top right
ggplot(bmw_models_edited, aes(x = mileage, y = price, color = as.factor(engineSize))) +
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 1.5) +
  geom_point(alpha = 0.35) +
  geom_text(
    data = label_positions,
    aes(
      x = x_pos, 
      y = y_pos, 
      label = paste0("Slope: ", round(slope, 3)),
      color = as.factor(engineSize)),
    hjust = 1,  # Right-align text
    vjust = 0,  # Top-align text
    show.legend = FALSE
  ) +
  facet_wrap(~model) +
  theme_bw() +
  labs(
    color = "Engine Size",
    title = "Power vs. Value: How Engine Size Affects BMW Series Depreciation",
    x = "Mileage",
    y = "Price ($)")+
theme(
    plot.title = element_text(size = 25),  # Adjust title size
    axis.title = element_text(size = 14)   # Adjust axis title size
)
```

The 2 Series equipped with the larger 3.0 liter engine demonstrates exceptional value retention compared to other models. Meanwhile, the 1 Series, 3 Series, and 5 Series tend to maintain their value better when fitted with the smallest engine.

As a car enthusiast (especially bmw enthusiast), I've always considered the 2 Series to be the perfect middle ground for performance, between the 3 and 1 series. I'm confident to say that performance-oriented buyers specifically look for 2 Series models with the biggest engine, creating a higher demand in the used market that supports their stronger value retention (3.0 L) compared to the 1.5 and 2.0 L options.


## 2. Family-Friendly & Durable (SUV)

```{r}

bmw_sales_edited <- bmw_sales %>% 
  mutate(year = str_sub(registration_date, 1, 4),
    model = ifelse(
      grepl("^[0-9]", model_key),  # If the model starts with a digit
      paste0(substr(model_key, 1, 1), " Series"),
      
      ifelse(
        grepl("^M", model_key) & nchar(model_key) > 2,  # If the model starts with "M" and is longer than 2 characters
        paste0(substr(model_key, 2, 2), " Series"),  # Skip the "M" and take the first digit
        
        ifelse(
          grepl("^M", model_key),  # If the model starts with "M" but is 2 characters or less (e.g., "M3", "M4")
          model_key,  # Keep "M3", "M4", etc. unchanged
          
          sub(" .*", "", model_key)  # Otherwise, take the first word
        )))) %>% rename(fuelType = fuel) %>% select(-registration_date)

bmw_sales_edited
```



```{r}
model_comparison <- bmw_sales_edited %>% filter(model_key %in% c("X1","X3","X4","X5","X6"), year>2010 & year<2016) 
```



```{r, fig.width=15}
# Calculate slopes for each model
slope_data <- model_comparison %>%
  group_by(model_key) %>%
  do(tidy(lm(price ~ mileage, data = .))) %>%
  filter(term == "mileage") %>%
  select(model_key, slope = estimate, std_error = std.error, p_value = p.value) %>%
  mutate(
    slope_formatted = round(slope, 4),
    price_decline_per_1000_miles = round(slope * 1000, 2),
    significance = case_when(
      p_value < 0.001 ~ "***",
      p_value < 0.01 ~ "**",
      p_value < 0.05 ~ "*",
      TRUE ~ "ns"
    )
  )

# Create the main visualization
ggplot(model_comparison, aes(x = mileage, y = price)) +
  geom_point() + 
  geom_smooth(method = "lm", se = FALSE, linetype = "dashed", size = 1.5) +
  facet_wrap(~ model_key, nrow = 1, scales = "free_x") +
  labs(
    title = "Diesel BMWs Maintain Value More Consistently as Mileage Increases Compared to Petrol",
    x = "Mileage",
    y = "Price ($)",
    color = "Fuel Type"
  ) +
  scale_x_continuous(labels = label_number(scale = 1/1000, suffix = "K")) +
  scale_y_continuous(labels = label_number(scale = 1/1000, suffix = "K"), limits = c(0, 50000)) +
  theme_bw() +
  theme(
    strip.text = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 16, face = "bold", hjust = 0.1),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "bottom",
    legend.title = element_text(face = "bold", size = 20),
    legend.text = element_text(size = 15),
    legend.key.size = unit(1.2, "lines"),
    panel.grid.major = element_line(color = "grey80", linetype = "dotted")
  )
```

```{r}
# Format table data
table_data <- slope_data %>%
  select(Model = model_key, 
         `Slope ($/mile)` = slope_formatted, 
         `Price Decline per 1,000 miles ($)` = price_decline_per_1000_miles)

# Function to create the table
create_slope_table <- function(data) {
  mytheme <- ttheme_minimal(
    core = list(
      fg_params = list(fontface = c(rep("plain", 1), rep("plain", nrow(data)))),
      bg_params = list(fill = c(rep("grey95", 1), rep("white", nrow(data))))
    ),
    colhead = list(fg_params = list(fontface = "bold", fontsize = 12)),
    rowhead = list(fg_params = list(fontface = "bold"))
  )
  
  tableGrob(data, rows = NULL, theme = mytheme)
}

slope_table <- create_slope_table(table_data)
grid.arrange(slope_table,
             vp = viewport(y = 0.8, height = 0.4)) # Position higher up (y=0.8 instead of default 0.5)
```



